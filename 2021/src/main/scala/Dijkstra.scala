import scala.annotation.tailrec

object Dijkstra {
  case class SPTitem[T](parent: T, dist: Int)

  //TODO: Create a "Graph" class that this operates on
  //Graph allows for getting vertex weights, edge weights, neighbours etc.
  /**
   * Perform a Dijkstra search on a graph
   * @param pq Priority queue of nodes to visit next
   * @param finish Target node we're looking for
   * @param spt Map for shortest path tree-information.
   * @param V Vertices in the map being searched + vertex weights
   * @param E Edges in the map being searched + edge weights
   * @tparam T
   * @return
   */
  @tailrec
  def doDijkstra[T](pq: PriorityQueue[T], finish: T, spt: Map[T, SPTitem[T]], V:Map[T, Int], E: Map[T, List[T]]): Map[T, SPTitem[T]] = {
    val v = pq.extract()
    if (v == finish) {
      spt
    } else {
      val nbs = E(v)
      val spt2 = nbs.foldLeft(spt)((SPT, nb) => relax(v, nb, V, SPT)) //Relax all outgoing edges
      for (nb <- nbs) {
        if (spt2(nb).dist < spt(nb).dist) {
          pq.decreasePrio(nb, spt2(nb).dist)
        }
      }
      doDijkstra(pq, finish, spt2, V, E)
    }
  }

  /**
   * Build the shortest path from start to finish based on the tree generated by doing Dijkstra search on a graph
   * @param spt Shortest path tree generated by [[doDijkstra]]
   * @param start Starting node of the path
   * @param current Current node of the path, looking to find path back to start
   * @param acc Accumulating parameter
   * @tparam T
   * @return List of (node, dist) tuples from start to finish
   */
  def buildShortestPath[T](spt: Map[T, SPTitem[T]], start: T, current: T, acc: List[(T, Int)]): List[(T, Int)] = {
    val node = (current, spt(current).dist)
    if (current == start) {
      node::acc
    } else {
      buildShortestPath(spt, start, spt(current).parent, node::acc)
    }
  }

  /**
   * Relax a vertex in the shortest-path tree, updating the distance estimate to a node
   * @param v1 The current vertex
   * @param v2 The vertex under consideration
   * @param V  Mapping from vertices to vertex weights in current map
   * @param spt Mapping from items to parent and distance estimate of items for shortest-path tree
   * @tparam T
   */
  private def relax[T](v1: T, v2: T, V: Map[T,Int], spt: Map[T, SPTitem[T]]): Map[T, SPTitem[T]] = {
    if (spt(v2).dist.toLong > spt(v1).dist.toLong + V(v2).toLong) { //Should saturate. Doesn't currently. Only add when encountered, or convert to long while computing?
      spt.updated(v2, SPTitem(v1, spt(v1).dist + V(v2)))
    } else {
      spt
    }
  }

  /**
   * Perform Dijkstra search on a graph
   * @param start Starting node
   * @param finish Finishing node
   * @param V map from vertices to vertex weights in the graph
   * @param E Map from vertices to neighbouring vertices in the graph
   * @tparam T
   * @return
   */
  def apply[T](start: T, finish: T, V: Map[T, Int], E: Map[T,List[T]]): List[(T, Int)] = {
    val pq = new PriorityQueue[T](0)
    //Insert all vertices into PQ for initial population. Remaining operations only require relaxation
    for (v <- V.keys) {
      pq.insert(v, Int.MaxValue)
    }
    //Create entries in shortest path tree, set starting node to distance 0
    val spt = V.keys.map(v => (v, SPTitem( v, Int.MaxValue))).toMap.updated(start, SPTitem(start, 0))
    pq.decreasePrio(start, 0)

    val SPT = doDijkstra(pq, finish, spt, V, E)
    buildShortestPath(SPT, start, finish, List.empty)
  }
}
